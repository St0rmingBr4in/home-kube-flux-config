name: Test K3s Deployment

on:
  push:
    branches: ["**"]
    paths:
      - "argocd/applications/**"
  pull_request:
    paths:
      - "argocd/applications/**"
  workflow_dispatch: # Allow manual triggering

env:
  COMMIT_SHA: ${{ github.sha }}

jobs:
  update-target-revisions:
    runs-on: ubuntu-latest
    outputs:
      commit-sha: ${{ steps.get-sha.outputs.sha }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Get current commit SHA
        id: get-sha
        run: echo "sha=${GITHUB_SHA}" >> $GITHUB_OUTPUT

      - name: Update targetRevision in application files
        run: |
          # Find all application.yaml files that reference our repository
          find argocd/applications -name "application.yaml" -type f | while read -r file; do
            if grep -q "github.com/St0rmingBr4in/home-kube-flux-config" "$file"; then
              echo "Updating $file..."
              # Replace targetRevision: HEAD with current commit SHA
              sed -i.bak "s|targetRevision: HEAD|targetRevision: ${GITHUB_SHA}|g" "$file"
              # Clean up backup files
              rm -f "$file.bak"
            fi
          done

      - name: Verify changes
        run: |
          echo "Modified files with new targetRevision:"
          git diff

      - name: Test specific application categories
        run: |
          echo "Testing application categories..."

          # Test that kustomization files are valid
          echo "=== Validating Kustomization files ==="
          find argocd/applications -name "kustomization.yaml" | while read -r file; do
            echo "Validating $file"
            kubectl kustomize "$(dirname "$file")" > /dev/null && echo "✓ Valid" || echo "✗ Invalid"
          done

      - name: Set up K3s cluster
        uses: debianmaster/actions-k3s@master
        id: k3s
        with:
          version: latest

      - name: Wait for K3s to be ready
        run: |
          kubectl wait --for=condition=Ready nodes --all --timeout=300s
          kubectl get nodes -o wide

      - name: Install ArgoCD
        run: |
          # Create ArgoCD namespace
          kubectl create namespace argocd

          # Install ArgoCD using the official manifests
          kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml

          # Wait for ArgoCD to be ready
          echo "Waiting for ArgoCD deployments..."
          kubectl wait --for=condition=available --timeout=600s deployment/argocd-server -n argocd
          kubectl wait --for=condition=available --timeout=600s deployment/argocd-repo-server -n argocd
          kubectl wait --for=condition=available --timeout=600s deployment/argocd-applicationset-controller -n argocd

      - name: Configure ArgoCD
        run: |
          # Get ArgoCD admin password
          ARGO_PASSWORD=$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)

          # Port forward ArgoCD server (run in background)
          kubectl port-forward svc/argocd-server -n argocd 8081:443 --address=0.0.0.0 > /dev/null 2>&1 &
          PORTFORWARD_PID=$!
          sleep 10

          # Login to ArgoCD CLI
          # First, download ArgoCD CLI
          curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
          sudo install -m 555 argocd-linux-amd64 /usr/local/bin/argocd
          rm argocd-linux-amd64

          # Login (disable TLS verification for local testing)
          argocd login localhost:8081 --username admin --password "$ARGO_PASSWORD" --insecure

          # Kill port forward
          kill $PORTFORWARD_PID || true

      - name: Test core ArgoCD applications
        run: |
          echo "Testing core ArgoCD applications..."

          # Apply the argocd-apps application first (this manages other applications)
          kubectl apply -f argocd/applications/core/argocd-apps/application.yaml

          # Wait a moment for ArgoCD to process
          sleep 30

          # Check if applications are created
          kubectl get applications -n argocd

      - name: Validate application health
        run: |
          echo "Checking ArgoCD application status..."

          # Port forward again for CLI commands
          kubectl port-forward svc/argocd-server -n argocd 8081:443 --address=0.0.0.0 > /dev/null 2>&1 &
          PORTFORWARD_PID=$!
          sleep 10

          # Re-login
          ARGO_PASSWORD=$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)
          argocd login localhost:8081 --username admin --password "$ARGO_PASSWORD" --insecure

          # List all applications and check their sync/health status
          echo "=== ArgoCD Applications ==="
          argocd app list

          # Wait for applications to sync and become healthy (30s timeout)
          echo "=== Waiting for applications to sync and become healthy ==="
          TIMEOUT=300
          FAILED_APPS=()

          # Get list of application names
          APPS=$(argocd app list -o name 2>/dev/null || echo "")

          if [ -n "$APPS" ]; then
            # Function to check a single app
            check_app() {
              local app="$1"
              echo "Checking $app..."
              START_TIME=$(date +%s)
              PREV_SYNC_STATUS=""
              PREV_HEALTH_STATUS=""
              
              while [ $(($(date +%s) - START_TIME)) -lt $TIMEOUT ]; do
                SYNC_STATUS=$(argocd app get "$app" -o json 2>/dev/null | jq -r '.status.sync.status // "Unknown"')
                HEALTH_STATUS=$(argocd app get "$app" -o json 2>/dev/null | jq -r '.status.health.status // "Unknown"')
                
                if [ "$SYNC_STATUS" = "Synced" ] && [ "$HEALTH_STATUS" = "Healthy" ]; then
                  echo "✓ $app: Synced and Healthy"
                  return 0
                fi
                
                # Only log if status changed
                if [ "$SYNC_STATUS" != "$PREV_SYNC_STATUS" ] || [ "$HEALTH_STATUS" != "$PREV_HEALTH_STATUS" ]; then
                  echo "  $app: Sync=$SYNC_STATUS, Health=$HEALTH_STATUS (waiting...)"
                  PREV_SYNC_STATUS="$SYNC_STATUS"
                  PREV_HEALTH_STATUS="$HEALTH_STATUS"
                fi
                
                sleep 5
              done
              
              # Final check after timeout
              FINAL_SYNC=$(argocd app get "$app" -o json 2>/dev/null | jq -r '.status.sync.status // "Unknown"')
              FINAL_HEALTH=$(argocd app get "$app" -o json 2>/dev/null | jq -r '.status.health.status // "Unknown"')

              echo "✗ $app: Failed to reach Synced+Healthy within ${TIMEOUT}s (Sync=$FINAL_SYNC, Health=$FINAL_HEALTH)"
              echo "$app" >> /tmp/failed_apps.txt
              return 1
            }

            # Initialize failed apps file
            rm -f /tmp/failed_apps.txt

            # Start background jobs for each app
            PIDS=()
            for app in $APPS; do
              check_app "$app" &
              PIDS+=($!)
            done

            # Wait for all background jobs to complete
            for pid in "${PIDS[@]}"; do
              wait $pid
            done

            # Read failed apps from temp file
            if [ -f /tmp/failed_apps.txt ]; then
              readarray -t FAILED_APPS < /tmp/failed_apps.txt
            fi
          else
            echo "No applications found"
          fi

          # Report failed applications
          if [ ${#FAILED_APPS[@]} -gt 0 ]; then
            echo "=== Applications that failed to sync/become healthy within ${TIMEOUT}s ==="
            for app in "${FAILED_APPS[@]}"; do
              echo "- $app"
            done
          else
            echo "=== All applications successfully synced and healthy ==="
          fi

          # Get detailed status of the argocd-apps application
          echo "=== ArgoCD Apps Application Status ==="
          argocd app get argocd-apps || echo "argocd-apps application not found"

          # Kill port forward
          kill $PORTFORWARD_PID || true

      - name: Summary
        if: always()
        run: |
          echo "=== Test Summary ==="
          echo "K3s cluster info:"
          kubectl cluster-info

          echo "=== All pods ==="
          kubectl get pods -A

          echo "=== ArgoCD Applications ==="
          kubectl get applications -n argocd || echo "No applications found"

          echo "=== Nodes ==="
          kubectl get nodes
