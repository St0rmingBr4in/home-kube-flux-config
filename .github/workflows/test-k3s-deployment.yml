name: Test K3s Deployment

on:
  push:
    branches: ["**"]
    paths:
      - "argocd/applications/**"
      - ".github/workflows/test-k3s-deployment.yml"
  pull_request:
    paths:
      - "argocd/applications/**"
      - ".github/workflows/test-k3s-deployment.yml"
  workflow_dispatch: # Allow manual triggering

env:
  COMMIT_SHA: ${{ github.sha }}

jobs:
  update-target-revisions:
    runs-on: ubuntu-latest
    outputs:
      commit-sha: ${{ steps.get-sha.outputs.sha }}
    steps:
      - name: Checkout code
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6

      - name: Get current commit SHA
        id: get-sha
        run: echo "sha=${GITHUB_SHA}" >> $GITHUB_OUTPUT

      - name: Update targetRevision in application files
        run: |
          # Find all application.yaml files that reference our repository
          find argocd/applications -name "application.yaml" -type f | while read -r file; do
            if grep -q "github.com/St0rmingBr4in/home-kube-flux-config" "$file"; then
              echo "Updating $file..."
              # Replace targetRevision: HEAD with current commit SHA
              sed -i.bak "s|targetRevision: HEAD|targetRevision: ${GITHUB_SHA}|g" "$file"
              # Clean up backup files
              rm -f "$file.bak"
            fi
          done

      - name: Verify changes
        run: |
          echo "Modified files with new targetRevision:"
          git diff

      - name: Test specific application categories
        run: |
          echo "Testing application categories..."

          # Test that kustomization files are valid
          echo "=== Validating Kustomization files ==="
          find argocd/applications -name "kustomization.yaml" | while read -r file; do
            echo "Validating $file"
            kubectl kustomize "$(dirname "$file")" > /dev/null && echo "✓ Valid" || echo "✗ Invalid"
          done

      - name: Set up K3s cluster
        uses: debianmaster/actions-k3s@master
        id: k3s
        with:
          version: latest
          args: --disable=servicelb --disable=traefik

      - name: Wait for K3s to be ready
        run: |
          kubectl wait --for=condition=Ready nodes --all --timeout=300s
          # Wait for CoreDNS pods to be ready: ensures pod networking (flannel/CNI)
          # is up before deploying anything. Uses pod labels rather than the
          # deployment name because newer k3s versions deploy CoreDNS via a
          # HelmChart controller and the Deployment may not exist immediately.
          echo "Waiting for CoreDNS pods to appear..."
          timeout 120 sh -c 'until kubectl get pods -n kube-system -l k8s-app=kube-dns -o name 2>/dev/null | grep -q pod; do sleep 2; done'
          kubectl wait --for=condition=Ready pod -l k8s-app=kube-dns -n kube-system --timeout=120s
          kubectl get nodes -o wide

      - name: Install ArgoCD
        run: |
          # Create ArgoCD namespace
          kubectl create namespace argocd

          # Install ArgoCD using the official manifests.
          # --server-side is required: the applicationsets CRD exceeds the 262144-byte
          # client-side annotation limit used by regular kubectl apply.
          kubectl apply --server-side -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml

          # Wait for ArgoCD to be ready
          echo "Waiting for ArgoCD deployments..."
          kubectl wait --for=condition=available --timeout=600s deployment/argocd-server -n argocd
          kubectl wait --for=condition=available --timeout=600s deployment/argocd-repo-server -n argocd
          kubectl wait --for=condition=available --timeout=600s deployment/argocd-applicationset-controller -n argocd

      - name: Configure ArgoCD
        run: |
          # Get ArgoCD admin password
          ARGO_PASSWORD=$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)

          # Port forward ArgoCD server (run in background)
          kubectl port-forward svc/argocd-server -n argocd 8081:443 --address=0.0.0.0 > /dev/null 2>&1 &
          PORTFORWARD_PID=$!
          sleep 10

          # Login to ArgoCD CLI
          # First, download ArgoCD CLI
          curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
          sudo install -m 555 argocd-linux-amd64 /usr/local/bin/argocd
          rm argocd-linux-amd64

          # Login (disable TLS verification for local testing)
          argocd login localhost:8081 --username admin --password "$ARGO_PASSWORD" --insecure

          # Kill port forward
          kill $PORTFORWARD_PID || true

      - name: Apply applications
        run: |
          kubectl apply -k argocd/applications/

          # Check if applications are created
          kubectl get applications -n argocd

      - name: Validate application health
        run: |
          echo "Checking ArgoCD application status..."

          # Port forward again for CLI commands
          kubectl port-forward svc/argocd-server -n argocd 8081:443 --address=0.0.0.0 > /dev/null 2>&1 &
          PORTFORWARD_PID=$!
          sleep 10

          # Re-login
          ARGO_PASSWORD=$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)
          argocd login localhost:8081 --username admin --password "$ARGO_PASSWORD" --insecure

          # List all applications and check their sync/health status
          echo "=== ArgoCD Applications ==="
          argocd app list

          # Apps excluded from CI health checks due to production infrastructure dependencies.
          # Reasons:
          #   - iSCSI NAS storage: apps with PVs pointing to 192.168.42.42 (production NAS)
          #   - VaultStaticSecret CRD: requires vault-secrets-operator to be initialized first
          #   - Production secrets: Datadog API key, Tailscale auth key, etc.
          #   - cert-manager CRDs: ClusterIssuer/Certificate CRDs unavailable until cert-manager is healthy
          #   - Self-referential: ArgoCD managing its own Helm deployment
          EXCLUDED_APPS=(
            "argocd/argocd"                          # Self-referential: ArgoCD managing itself via Helm
            "argocd/authentik"                       # Requires VaultStaticSecret CRD + production secrets
            "argocd/bazarr"                          # Requires iSCSI NAS storage (192.168.42.42)
            "argocd/cert-manager"                    # Pods remain Pending in CI environment
            "argocd/cert-manager-letsencrypt-issuer" # Requires cert-manager CRDs + ACME challenge
            "argocd/cert-manager-selfsigned-issuer"  # Requires cert-manager CRDs to be operational
            "argocd/datadog"                         # Requires Datadog API key secret
            "argocd/flaresolverr"                    # Pods remain Pending in CI environment
            "argocd/jellyfin"                        # Requires iSCSI NAS storage (192.168.42.42)
            "argocd/jellyseerr"                      # Requires iSCSI NAS storage (192.168.42.42)
            "argocd/memory-webhook"                  # Requires cert-manager CRDs for webhook TLS cert
            "argocd/prowlarr"                        # Requires iSCSI NAS storage + Traefik IngressRoute CRDs
            "argocd/qbittorrent"                     # Requires VaultStaticSecret CRD + iSCSI NAS storage
            "argocd/radarr"                          # Requires iSCSI NAS storage + Traefik IngressRoute CRDs
            "argocd/sonarr"                          # Requires iSCSI NAS storage + Traefik IngressRoute CRDs
            "argocd/st0rmingbr4in.com-cert"          # Requires cert-manager CRDs
            "argocd/tailscale-operator"              # Requires Tailscale auth key secret
            "argocd/traefik"                         # Requires VaultStaticSecret CRD in manifests path
            "argocd/pihole"                          # Liveness probe checks DNS functionality unavailable in CI
            "argocd/vault"                           # Requires manual Vault initialization
            "argocd/vault-secrets-operator"          # upgrade-crds job remains Pending in CI
          )

          is_excluded() {
            local app="$1"
            for excluded in "${EXCLUDED_APPS[@]}"; do
              [ "$app" = "$excluded" ] && return 0
            done
            return 1
          }

          # Wait for applications to sync and become healthy (600s timeout)
          # homepage pulls images from oci.trueforge.org which can take 4-5 minutes
          echo "=== Waiting for applications to sync and become healthy ==="
          TIMEOUT=600
          FAILED_APPS=()

          # Get list of all application names to check
          APPS=$(argocd app list -o name 2>/dev/null || echo "")

          if [ -n "$APPS" ]; then
            # Function to check a single app
            check_app() {
              local app="$1"
              echo "Checking $app..."
              START_TIME=$(date +%s)
              PREV_SYNC_STATUS=""
              PREV_HEALTH_STATUS=""

              while [ $(($(date +%s) - START_TIME)) -lt $TIMEOUT ]; do
                SYNC_STATUS=$(argocd app get "$app" -o json 2>/dev/null | jq -r '.status.sync.status // "Unknown"')
                HEALTH_STATUS=$(argocd app get "$app" -o json 2>/dev/null | jq -r '.status.health.status // "Unknown"')

                if [ "$SYNC_STATUS" = "Synced" ] && [ "$HEALTH_STATUS" = "Healthy" ]; then
                  echo "✓ $app: Synced and Healthy"
                  return 0
                fi

                # Only log if status changed
                if [ "$SYNC_STATUS" != "$PREV_SYNC_STATUS" ] || [ "$HEALTH_STATUS" != "$PREV_HEALTH_STATUS" ]; then
                  echo "  $app: Sync=$SYNC_STATUS, Health=$HEALTH_STATUS (waiting...)"
                  PREV_SYNC_STATUS="$SYNC_STATUS"
                  PREV_HEALTH_STATUS="$HEALTH_STATUS"
                fi

                sleep 5
              done

              # Final check after timeout
              FINAL_SYNC=$(argocd app get "$app" -o json 2>/dev/null | jq -r '.status.sync.status // "Unknown"')
              FINAL_HEALTH=$(argocd app get "$app" -o json 2>/dev/null | jq -r '.status.health.status // "Unknown"')

              echo "✗ $app: Failed to reach Synced+Healthy within ${TIMEOUT}s (Sync=$FINAL_SYNC, Health=$FINAL_HEALTH)"
              echo "$app" >> /tmp/failed_apps.txt
              return 1
            }

            # Initialize failed apps file
            rm -f /tmp/failed_apps.txt

            # Start background jobs for each non-excluded app
            PIDS=()
            for app in $APPS; do
              if is_excluded "$app"; then
                echo "⏭ $app: Skipped (excluded - requires production infrastructure)"
                continue
              fi
              check_app "$app" &
              PIDS+=($!)
            done

            # Wait for all background jobs to complete
            for pid in "${PIDS[@]}"; do
              wait $pid
            done

            # Read failed apps from temp file
            if [ -f /tmp/failed_apps.txt ]; then
              readarray -t FAILED_APPS < /tmp/failed_apps.txt
            fi
          else
            echo "No applications found"
          fi

          # Report results
          echo ""
          echo "=== Excluded Applications (require production infrastructure) ==="
          for app in "${EXCLUDED_APPS[@]}"; do
            echo "  ⏭ $app"
          done

          if [ ${#FAILED_APPS[@]} -gt 0 ]; then
            echo ""
            echo "=== Applications that failed to sync/become healthy within ${TIMEOUT}s ==="
            for app in "${FAILED_APPS[@]}"; do
              echo "  ✗ $app"
            done
            exit 1
          else
            echo ""
            echo "=== All testable applications successfully synced and healthy ==="
          fi

          # Get detailed status of the argocd-apps application
          echo "=== ArgoCD Apps Application Status ==="
          argocd app get argocd-apps || echo "argocd-apps application not found"

          # Kill port forward
          kill $PORTFORWARD_PID || true

      - name: Summary
        if: always()
        run: |
          echo "=== Test Summary ==="
          echo "K3s cluster info:"
          kubectl cluster-info

          echo "=== All pods ==="
          kubectl get pods -A

          echo "=== ArgoCD Applications ==="
          kubectl get applications -n argocd || echo "No applications found"

          echo "=== ArgoCD Applications Details ==="
          kubectl describe applications -n argocd || echo "No applications found to describe"

          echo "=== ArgoCD Pod Status ==="
          kubectl get pods -n argocd || echo "ArgoCD namespace not found"

          echo "=== ArgoCD Server Logs (last 50 lines) ==="
          kubectl logs -n argocd -l app.kubernetes.io/name=argocd-server --tail=50 || echo "ArgoCD server logs not available"

          echo "=== ArgoCD Application Controller Logs (last 50 lines) ==="
          kubectl logs -n argocd -l app.kubernetes.io/name=argocd-application-controller --tail=50 || echo "ArgoCD application controller logs not available"

          echo "=== ArgoCD Repo Server Logs (last 50 lines) ==="
          kubectl logs -n argocd -l app.kubernetes.io/name=argocd-repo-server --tail=50 || echo "ArgoCD repo server logs not available"

          echo "=== ArgoCD Events ==="
          kubectl get events -n argocd --sort-by='.lastTimestamp' || echo "No events found in argocd namespace"

          echo "=== Cluster Events (last 20) ==="
          kubectl get events --all-namespaces --sort-by='.lastTimestamp' | tail -20 || echo "No cluster events found"

          echo "=== Nodes ==="
          kubectl get nodes

          echo "=== Node Conditions ==="
          kubectl describe nodes || echo "Could not describe nodes"
